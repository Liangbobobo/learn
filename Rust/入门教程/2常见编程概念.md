
 第三章  变量  
3.1 变量和可变性  
变量默认是不可改变的（immutable），一旦值被绑定一个名称上，就不能改变这个值。
let mut 使变量可变

变量和常量的区别
常量（constants）常量是绑定到一个名称的不允许改变的值
1.不允许对常量使用 mut。常量不光默认不能变，它总是不能变
2.声明常量使用 const 关键字而不是 let，并且 必须 注明值的类型
3.常量可以在任何作用域中声明，包括全局作用域，这在一个值需要被很多部分的代码用到时很有用。
4.常量只能被设置为常量表达式，而不能是函数调用的结果，或任何其他只能在运行时计算出的值。

隐藏（Shadowing）
可以用相同变量名称来隐藏一个变量，以及重复使用 let 关键字来多次隐藏
let x = 5;
let x = x + 1;
let x = x * 2;

隐藏与将变量标记为 mut 区别：
1.通过使用 let，我们可以用这个值进行一些计算，但是计算完后的变量仍然是不可变的。
2.再次使用 let 时，实际上创建了一个新变量，我们可以改变值的类型，但复用这个名字
而使用mut时，重新赋值不能改变变量类型


3.2数据类型
Rust 中，每一个值都属于某一个 数据类型（data type）以便明确数据处理方式。
Rust 是 静态类型（statically typed）语言，也就是说在编译时就必须知道所有变量的类型。根据值及其使用方式，编译器通常可以推断出我们想要用的类型。当多种类型均有可能时，必须增加类型注解：
let guess: u32 = "42".parse().expect("Not a number!");

标量（scalar）类型：
代表一个单独的值。Rust 有四种基本的标量类型：整型、浮点型、布尔类型和字符类型。
整形，8-bit 有符号i8，无符号u8
每一个有符号的变体可以储存包含从 -(2n - 1) 到 2n - 1 - 1 在内的数字，无符号的变体可以储存从 0 到 2n - 1 的数字。
isize 和 usize 类型依赖运行程序的计算机架构：64 位架构上它们是 64 位的， 32 位架构上它们是 32 位的。


## 3.2 复合类型（Compound types）可以将多个值组合成一个类型
Rust 有两个原生的复合类型：元组（tuple）和数组（array）。   
元组类型：  
元组是一个将多个其他类型的值组合进一个复合类型的主要方式。   
元组长度固定：一旦声明，其长度不会增大或缩小。  

使用包含在圆括号中的逗号分隔的值列表来创建一个元组。元组中的每一个位置都有一个类型，而且这些不同值的类型也不必是相同的。
```
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
```
因为元组是一个单独的复合元素。为了从元组中获取单个值，可以使用模式匹配（pattern matching）来解构（destructure）元组值

```
fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {}", y);
}
```
程序首先创建了一个元组并绑定到 tup 变量上。接着使用了 let 和一个模式将 tup 分成了三个不同的变量，x、y 和 z。这叫做 解构（destructuring），因为它将一个元组拆成了三个部分。最后，程序打印出了 y 的值，也就是 6.4。

也可以使用点号（.）后跟值的索引来直接访问它们:  
tup.0;tup.1;tup.2
元组的第一个索引值是 0。  

### 数组类型 另一个包含多个值的方式是 数组（array），数组是一整块分配在栈上的内存
Rust中数组的每个元素的类型必须相同，一旦声明，它们的长度不能增长或缩小。  
你想要在栈（stack）而不是在堆（heap）上为数据分配空间  
或想要确保总是有固定数量的元素时  
数组非常有用

数组并不如 vector 类型灵活。vector 类型是标准库提供的一个 允许 增长和缩小长度的类似数组的集合类型。   
当不确定是应该使用数组还是 vector 的时候，你可能应该使用 vector。

let a: [i32; 5] = [1, 2, 3, 4, 5];
i32 是每个元素的类型。分号之后，数字 5 表明该数组包含五个元素。  

let a = [3; 5];
变量名为 a 的数组将包含 5 个元素，这些元素的值最初都将被设置为 3 

可以使用索引来访问数组的元素  
当尝试用索引访问一个元素时，Rust 会检查指定的索引是否小于数组的长度。如果索引超出了数组长度，Rust 会 panic，这是 Rust 术语，它用于程序因为错误而退出的情况。

# 函数
Rust 代码中的函数和变量名，所有字母都是小写并使用下划线分隔单词。

Rust 不关心函数定义于何处，只要定义了就行
## 函数参数
函数也可以被定义为拥有 参数（parameters），参数是特殊变量，是函数签名的一部分。当函数拥有参数（形参）时，可以为这些参数提供具体的值（实参）。技术上讲，这些具体值被称为参数（arguments，实参）

在函数签名中，必须 声明每个参数的类型。

## 函数体
函数体由一系列的语句和一个可选的结尾表达式构成

Rust 是一门基于表达式（expression-based）的语言，语句（Statements）是执行一些操作但不返回值的指令。表达式（Expressions）计算并产生一个值：
```
fn main() {
    let x = (let y = 6);
}
```
let y = 6 语句并不返回值，所以没有可以绑定到 x 上的值。这与其他语言不同，例如 C 和 Ruby，它们的赋值语句会返回所赋的值

表达式会计算出一些值:5 + 6，这是一个表达式并计算出值 11    
表达式可以是语句的一部分:let y = 6; 中的 6 是一个表达式，它计算出的值是 6
函数调用是一个表达式。宏调用是一个表达式。我们用来创建新作用域的大括号（代码块），{}，也是一个表达式  

eg:
```
fn main() {
    let x = 5;

    let y = {
        let x = 3;
        x + 1
    };

    println!("The value of y is: {}", y);
}

    {
        let x = 3;
        x + 1
    }
    这个表达式是一个代码块，它的值是 4。这个值作为 let 语句的一部分被绑定到 y 上,注意结尾没有分号的那一行 x+1，与你见过的大部分代码行不同。表达式的结尾没有分号。  
    如果在表达式的结尾加上分号，它就变成了语句，而语句不会返回值。在接下来探索具有返回值的函数和表达式时要谨记这一点。
```

### 具有返回值的函数
函数可以向调用它的代码返回值。   
我们并不对返回值命名，但要在箭头（->）后声明它的类型。  
Rust 中，函数的返回值等同于函数体最后一个表达式的值。使用 return 关键字和指定值，可从函数中提前返回；但大部分函数隐式的返回最后的表达式。  

eg:
```
fn five() -> i32 {
    5 
    //five 函数没有参数并定义了返回值类型，不过函数体只有单单一个 5 也没有分号，因为这是一个表达式，我们想要返回它的值。
}

fn main() {
    let x = five();//等于let x = 5;

    println!("The value of x is: {}", x);
}
```

### 控制流
主要是if控制流，  
if后面如果跟的时单一的表达式，可是省略（）  
代码中的条件 必须是 bool 值。如果条件不是 bool 值，我们将得到一个错误。  

    let number = 3;

    if number {
        println!("number was three");

这里if条件的值是3，Rust会抛出一个错误。

Rust 并不会尝试自动地将非布尔值转换为布尔值。必须总是显式地使用布尔值作为 if 的条件
```
fn main() {
    let number = 3;

    if number != 0 {
        println!("number was something other than zero");
    }
}
```
可以将 else if 表达式与 if 和 else 组合来实现多重条件
```
 if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}
```

### 在 let 语句中使用 if
因为 if 是一个表达式，我们可以在 let 语句的右侧使用它,将 if 表达式的返回值赋给一个变量  
```
fn main() {
    let condition = true;
    let number = if condition {
        5
    } else {
        6
    };

    println!("The value of number is: {}", number);
}
```

代码块的值是其最后一个表达式的值，而数字本身就是一个表达式。  
在这个例子中，整个 if 表达式的值取决于哪个代码块被执行。这意味着 if 的每个分支的可能的返回值都必须是相同类型,否则编译器会报错。  

if 代码块中的表达式返回一个整数，而 else 代码块中的表达式返回一个字符串。这不可行，因为变量必须只有一个类型。Rust 需要在编译时就确切的知道 number 变量的类型，这样它就可以在编译时验证在每处使用的 number 变量的类型是有效的。  
Rust 并不能够在 number 的类型只能在运行时确定的情况下工作；  
这样会使编译器变得更复杂而且只能为代码提供更少的保障，因为它不得不记录所有变量的多种可能的类型。

### 使用循环重复执行
多次执行同一段代码是很常用的，Rust 为此提供了多种 循环（loops）。  
Rust 有三种循环：loop、while 和 for   
loop：loop 关键字告诉 Rust 一遍又一遍地执行一段代码直到你明确要求停止  


```
fn main() {
    loop {
        println!("again!");
    }
}

ctrl-c，来终止一个陷入无限循环的程序,或
将返回值加入你用来停止循环的 break 表达式，它会被停止的循环返回  
也可以使用 break 关键字来告诉程序何时停止循环,并返回break后面的关键字。
```

```
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a.iter() {
        println!("the value is: {}", element);
    }
}
```

while 条件循环  

使用 for 遍历集合


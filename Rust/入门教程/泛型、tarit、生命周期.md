# 泛型数据类型

## 在函数定义中使用泛型
使用泛型定义函数时，本来在函数签名中指定参数和返回值的类型的地方，会改用泛型来表示。

Rust 类型名的命名规范是骆驼命名法（CamelCase）

要在函数体中使用参数，就必须在函数签名中声明它的名字，好让编译器知道这个名字指代的是什么。同理，当在函数签名中使用一个类型参数时，必须在使用它之前就声明它，类型参数声明位于函数名称与参数列表中间的尖括号 <> 中。
```
fn largest<T>(list: &[T]) -> T {
```

标准库中定义的 std::cmp::PartialOrd trait 可以实现类型的比较功能,>,< 号

## 结构体定义中的泛型
首先，必须在结构体名称后面的尖括号中声明泛型参数的名称。接着在结构体定义中可以指定具体数据类型的位置使用泛型类型。   
任一泛型类型只能代表一种具体类型，不同的泛型类型不能实例化为两个不同的具体类型
```
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
字段 x 和 y 都必须是 相同类型的
```

你可以在定义中使用任意多的泛型类型参数，不过太多的话，代码将难以阅读和理解。当你的代码中需要许多泛型类型时，它可能表明你的代码需要重构，分解成更小的结构。

## 枚举定义中的泛型
当你意识到代码中定义了多个结构体或枚举，它们不一样的地方只是其中的值的类型的时候，不妨通过泛型类型来避免重复。

## 方法定义中的泛型























# 生命周期
Rust 中的每一个引用都有其 生命周期（lifetime），也就是引用保持有效的作用域。  
当因为有多种可能类型的时候必须注明类型，也会出现引用的生命周期以一些不同方式相关联的情况，所以 Rust 需要我们使用泛型生命周期参数来注明他们的关系，这样就能确保运行时实际使用的引用绝对是有效的。

## 生命周期避免了悬垂引用 生命周期的主要目标是避免悬垂引用


## 函数签名中的生命周期注解
通过在函数签名中指定生命周期参数时，我们并没有改变任何传入值或返回值的生命周期，而是指出任何不满足这个约束条件的值都将被借用检查器拒绝。

## 结构体定义中的生命周期注解
定义包含引用的结构体，需要为结构体定义中的每一个引用添加生命周期注解。
# owership 所有权
通过所有权系统管理内存，编译器在编译时会根据一系列的规则进行检查。在运行时，所有权系统的任何功能都不会减慢程序。

## stack 堆 和 heap 栈 的异同
相同：栈和堆都是代码在运行时可供使用的内存；  
不同：  
1. 结构不同：栈，后进先出（last in, first out），增加数据叫做 进栈（pushing onto the stack），而移出数据叫做 出栈（popping off the stack）。 将数据推入栈中并不被认为是分配。因为指针的大小是已知并且固定的，你可以将指针存储在栈上，不过当需要实际数据时，必须访问指针。  
堆是缺乏组织的：当向堆放入数据时，你要请求一定大小的空间。操作系统在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的 指针（pointer）。这个过程称作 在堆上分配内存（allocating on the heap），有时简称为 “分配”（allocating）。
2. 栈中的所有数据都必须占用已知且固定的大小，  
在编译时大小未知或大小可能变化的数据，要改为存储在堆上
3. 消耗，入栈比在堆上分配内存要快。  
因为（入栈时）操作系统无需为存储新数据去搜索内存空间；其位置总是在栈顶。相比之下，在堆上分配内存则需要更多的工作，这是因为操作系统必须首先找到一块足够存放数据的内存空间，并接着做一些记录为下一次分配做准备。
4. 访问堆上的数据比访问栈上的数据慢，因为必须通过指针来访问。  
处理器在处理的数据彼此较近的时候（比如在栈上）比较远的时候（比如可能在堆上）能更好的工作。在堆上分配大量的空间也可能消耗时间。

栈的使用情形之一，当你的代码调用一个函数时，传递给函数的值（包括可能指向堆上数据的指针）和函数的局部变量被压入栈中。当函数结束时，这些值被移出栈。

## 所有权规则
1. Rust 中的每一个值都有一个被称为其 所有者（owner）的变量。
2. 值在任一时刻有且只有一个所有者。
3. 当所有者（变量）离开作用域，这个值将被丢弃。

### 内存与分配
对于一些大小未知、随着程序运行而改变内存大小的类型，比如string，为了支持一个可变，可增长的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容。这意味着：  
1. 必须在运行时向操作系统请求内存。
2. 需要一个当我们处理完 String 时将内存返回给操作系统的方法。  

第一部分由我们完成：当调用 String::from 时，它的实现 (implementation) 请求其所需的内存。这在编程语言中是非常通用的。  
对于第二部分，Rust 采取了一个不同的策略（和garbage collector，GC相比）：内存在拥有它的变量离开作用域后就被自动释放。下面是示例 4-1 中作用域例子的一个使用 String 而不是字符串字面值的版本：
```

{
    let s = String::from("hello"); // 从此处起，s 是有效的

    // 使用 s
}                                  // 此作用域已结束，
                                   // s 不再有效
```
这是一个将 String 需要的内存返回给操作系统的很自然的位置：当 s 离开作用域的时候。当变量离开作用域，Rust 为我们调用一个特殊的函数。这个函数叫做 drop，在这里 String 的作者可以放置释放内存的代码。Rust 在结尾的 } 处自动调用 drop。

## 现在让我们探索一些这样的场景:
### 变量与数据交互的方式（一）：移动
Rust 中的多个变量可以采用一种独特的方式与同一数据交互。  
```
let x = 5;
let y = x;
“将 5 绑定到 x；接着生成一个值 x 的拷贝并绑定到 y”。现在有了两个变量，x 和 y，都等于 5。这也正是事实上发生了的，因为整数是有已知固定大小的简单值，所以这两个 5 被放入了栈中。
```

```
let s1 = String::from("hello");
let s2 = s1;
```
上例中，当我们将 s1 赋值给 s2，String 的数据被复制了，这意味着我们从栈上拷贝了它的指针、长度和容量。我们并没有复制指针指向的堆上数据。换句话说，内存中数据的表现下图所示。

![](https://kaisery.github.io/trpl-zh-cn/img/trpl04-02.svg)

Rust 则认为 s1 不再有效，因此 Rust 不需要在 s1 离开作用域后清理任何东西。看看在 s2 被创建之后尝试使用 s1 会发生什么  

 如C++中的浅拷贝（shallow copy）和 深拷贝（deep copy），那么拷贝指针、长度和容量而不拷贝数据可能听起来像浅拷贝。不过因为 Rust 同时使第一个变量无效了，这个操作被称为 移动（move），而不是浅拷贝。   

![](https://kaisery.github.io/trpl-zh-cn/img/trpl04-04.svg)

因为只有 s2 是有效的，当其离开作用域，它就释放自己的内存，完毕。

Rust 永远也不会自动创建数据的 “深拷贝”。因此，任何 自动 的复制可以被认为对运行时性能影响较小。

### 变量与数据交互的方式（二）：克隆
如果我们 确实 需要深度复制 String 中堆上的数据，而不仅仅是栈上的数据，可以使用一个叫做 clone 的通用函数。   
```
let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {}, s2 = {}", s1, s2);
```

![](https://kaisery.github.io/trpl-zh-cn/img/trpl04-03.svg)

当出现 clone 调用时，你知道一些特定的代码被执行而且这些代码可能相当消耗资源。你很容易察觉到一些不寻常的事情正在发生。

### 只在栈上的数据：拷贝
```

let x = 5;
let y = x;

println!("x = {}, y = {}", x, y);
```

但这段代码似乎与我们刚刚学到的内容相矛盾：没有调用 clone，不过 x 依然有效且没有被移动到 y 中。

原因是像整型这样的在编译时已知大小的类型被整个存储在栈上，所以拷贝其实际的值是快速的。这意味着没有理由在创建变量 y 后使 x 无效。换句话说，这里没有深浅拷贝的区别，所以这里调用 clone 并不会与通常的浅拷贝有什么不同，我们可以不用管它。

Rust 有一个叫做 Copy trait 的特殊注解，可以用在类似整型这样的存储在栈上的类型上（第十章详细讲解 trait）。如果一个类型拥有 Copy trait，一个旧的变量在将其赋值给其他变量后仍然可用。

Rust 不允许自身或其任何部分实现了 Drop trait 的类型使用 Copy trait。如果我们对其值离开作用域时需要特殊处理的类型使用 Copy 注解，将会出现一个编译时错误。要学习如何为你的类型增加 Copy 注解，请阅读附录 C 中的 “可派生的 trait”。

那么什么类型是 Copy 的呢？可以查看给定类型的文档来确认，不过作为一个通用的规则，任何简单标量值的组合可以是 Copy 的，不需要分配内存或某种形式资源的类型是 Copy 的。如下是一些 Copy 的类型：


    所有整数类型，比如 u32。
    布尔类型，bool，它的值是 true 和 false。
    所有浮点数类型，比如 f64。
    字符类型，char。
    元组，当且仅当其包含的类型也都是 Copy 的时候。比如，(i32, i32) 是 Copy 的，但 (i32, String) 就不是。

## 所有权与函数
将值传递给函数在语义上与给变量赋值相似。向函数传递值可能会移动或者复制，就像赋值语句一样。示例 4-3 使用注释展示变量何时进入和离开作用域：
```
fn main() {
    let s = String::from("hello");  // s 进入作用域

    takes_ownership(s);             // s 的值移动到函数里 ...
                                    // ... 所以到这里不再有效

    let x = 5;                      // x 进入作用域

    makes_copy(x);                  // x 应该移动函数里，
                                    // 但 i32 是 Copy 的，所以在后面可继续使用 x

} // 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，
  // 所以不会有特殊操作

fn takes_ownership(some_string: String) { // some_string 进入作用域
    println!("{}", some_string);
} // 这里，some_string 移出作用域并调用 `drop` 方法。占用的内存被释放

fn makes_copy(some_integer: i32) { // some_integer 进入作用域
    println!("{}", some_integer);
} // 这里，some_integer 移出作用域。不会有特殊操作
```

## 返回值与作用域  
返回值也可以转移所有权
```
fn main() {
    let s1 = gives_ownership();         // gives_ownership 将返回值
                                        // 移给 s1

    let s2 = String::from("hello");     // s2 进入作用域

    let s3 = takes_and_gives_back(s2);  // s2 被移动到
                                        // takes_and_gives_back 中,
                                        // 它也将返回值移给 s3
} // 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，
  // 所以什么也不会发生。s1 移出作用域并被丢弃

fn gives_ownership() -> String {             // gives_ownership 将返回值移动给
                                             // 调用它的函数

    let some_string = String::from("hello"); // some_string 进入作用域.

    some_string                              // 返回 some_string 并移出给调用的函数
}

// takes_and_gives_back 将传入字符串并返回该值
fn takes_and_gives_back(a_string: String) -> String { // a_string 进入作用域

    a_string  // 返回 a_string 并移出给调用的函数
}
```

### 变量的所有权总是遵循相同的模式：将值赋给另一个变量时移动它。当持有堆中数据值的变量离开作用域时，其值将通过 drop 被清理掉，除非数据被移动为另一个变量所有。

# 引用与借用
引用：& ，允许你使用值但不获取其所有权。因为并不拥有这个值，当引用离开作用域时其指向的值也不会被丢弃.   

正如变量默认是不可变的，引用也一样。（默认）不允许修改引用的值。


![](https://kaisery.github.io/trpl-zh-cn/img/trpl04-05.svg)

我们将获取引用作为函数参数称为 借用（borrowing）。

## 可变引用
1. 在特定作用域中的特定数据只能有一个可变引用。  

2. 可以使用大括号来创建一个新的作用域，以允许拥有多个可变引用，只是不能 同时 拥有:
```

let mut s = String::from("hello");

{
    let r1 = &mut s;

} // r1 在这里离开了作用域，所以我们完全可以创建一个新的引用

let r2 = &mut s;
```

3. 也 不能在拥有不可变引用的同时拥有可变引用。  
4. 多个不可变引用是可以的，因为没有哪个只能读取数据的人有能力影响其他人读取到的数据。

5. 一个引用的作用域从声明的地方开始一直持续到最后一次使用为止。例如，因为最后一次使用不可变引用在声明可变引用之前
```
let mut s = String::from("hello");

let r1 = &s; // 没问题
let r2 = &s; // 没问题
println!("{} and {}", r1, r2);
// 此位置之后 r1 和 r2 不再使用

let r3 = &mut s; // 没问题
println!("{}", r3);
```

## 悬垂引用（Dangling References）
悬垂指针是其指向的内存可能已经被分配给其它持有者。  

在 Rust 中编译器确保引用永远也不会变成悬垂状态：当你拥有一些数据的引用，编译器确保数据不会在其引用之前离开作用域。

Rust 中的每一个引用都有其 生命周期（lifetime），也就是引用保持有效的作用域。  



## 生命周期与引用有效性
Rust 中的每一个引用都有其 生命周期（lifetime），也就是引用保持有效的作用域。

 Rust 中可以存在声明了没有初始值的变量，所以这些变量存在于外部作用域。这乍看之下好像和 Rust 不允许存在空值相冲突。然而如果尝试在给它一个值之前使用这个变量，会出现一个编译时错误，这就说明了 Rust 确实不允许空值。
```
{
    let r;

    {
        let x = 5;
        r = &x;
    }

    println!("r: {}", r);
}
外部作用域声明了一个没有初值的变量 r，而内部作用域声明了一个初值为 5 的变量x。在内部作用域中，我们尝试将 r 的值设置为一个 x 的引用。接着在内部作用域结束后，尝试打印出 r 的值。这段代码不能编译因为 r 引用的值在尝试使用之前就离开了作用域。
```
## 生命周期注解语法
当在函数中使用生命周期注解时，这些注解出现在函数签名中，而不存在于函数体中的任何代码中。

生命周期注解并不改变任何引用的生命周期的长短。而是指出任何不满足这个约束条件的值都将被借用检查器拒绝。   
当指定了泛型生命周期后函数也能接受任何生命周期的引用。  
生命周期注解描述了多个引用生命周期相互的关系，而不影响其生命周期。   


泛型生命周期参数需要声明在函数名和参数列表间的尖括号中
```
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

这里我们想要告诉 Rust 关于参数中的引用和返回值之间的限制是他们都必须拥有相同的生命周期。

longest 函数返回的引用的生命周期与传入该函数的引用的生命周期的较小者一致。这就是我们告诉 Rust 需要其保证的约束条件。
```
```
fn main() {
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        result = longest(string1.as_str(), string2.as_str());
    }
    println!("The longest string is {}", result);
}
如果从人的角度读上述代码，我们可能会觉得这个代码是正确的。 string1 更长，因此 result 会包含指向 string1 的引用。因为 string1 尚未离开作用域，对于 println! 来说 string1 的引用仍然是有效的。然而，我们通过生命周期参数告诉 Rust 的是： longest 函数返回的引用的生命周期应该与传入参数的生命周期中较短那个保持一致。因此，借用检查器不允许示例 10-24 中的代码，因为它可能会存在无效的引用。

```

## 深入理解生命周期
指定生命周期参数的正确方式依赖函数实现的具体功能。例如，如果将 longest 函数的实现修改为总是返回第一个参数而不是最长的字符串 slice，就不需要为参数 y 指定一个生命周期。如下代码将能够编译：
```

fn longest<'a>(x: &'a str, y: &str) -> &'a str {
    x
}
在这个例子中，我们为参数 x 和返回值指定了生命周期参数 'a，不过没有为参数 y 指定，因为 y 的生命周期与参数 x 和返回值的生命周期没有任何关系。
```

当从函数返回一个引用，返回值的生命周期参数需要与一个参数的生命周期参数相匹配。如果返回的引用 没有 指向任何一个参数，那么唯一的可能就是它指向一个函数内部创建的值，它将会是一个悬垂引用，因为它将会在函数结束时离开作用域。

```
fn longest<'a>(x: &str, y: &str) -> &'a str {
    let result = String::from("really long string");
    result.as_str()
}
出现的问题是 result 在 longest 函数的结尾将离开作用域并被清理，而我们尝试从函数返回一个 result 的引用。无法指定生命周期参数来改变悬垂引用，而且 Rust 也不允许我们创建一个悬垂引用。在这种情况，最好的解决方案是返回一个有所有权的数据类型而不是一个引用，这样函数调用者就需要负责清理这个值了。

综上，生命周期语法是用于将函数的多个参数与其返回值的生命周期进行关联的。一旦他们形成了某种关联，Rust 就有了足够的信息来允许内存安全的操作并阻止会产生悬垂指针亦或是违反内存安全的行为。
```


# 字符串
Rust 的核心语言中只有一种字符串类型：str  
字符串 slice，它通常以被借用的形式出现，&str。

String 的类型是由标准库提供的，而没有写进核心语言部分  
它是可增长的、可变的、有所有权的、UTF-8 编码的字符串类型。  
当 Rustacean 们谈到 Rust 的 “字符串”时，它们通常指的是 String 和字符串 slice &str 类型，而不仅仅是其中之一。

String 和字符串 slice 都是 UTF-8 编码的。

## 新建字符串
第一种：   
```
新建一个空的 String
let mut s = String::new();
```
第二种：
```
使用 to_string 方法从字符串字面值创建 String  
to_string 方法，它能用于任何实现了 Display trait 的类型，字符串字面值也实现了它
let data = "initial contents";

let s = data.to_string();

// 该方法也可直接用于字符串字面值：
let s = "initial contents".to_string();

```

第三种：
```
使用 String::from 函数来从字符串字面值创建 String。
let s = String::from("initial contents");
```


字符串是 UTF-8 编码的，所以可以包含任何可以正确编码的数据

## 更新字符串
String 的大小可以增加，其内容也可以改变，就像可以放入更多数据来改变 Vec 的内容一样。  
可以方便的使用 + 运算符或 format! 宏来拼接 String 值。   

1. push_str,push_str 方法采用字符串 slice并不获取所有权     
```
let mut s1 = String::from("foo");
let s2 = "bar";
s1.push_str(s2);
println!("s2 is {}", s2);
```

2. push 方法被定义为获取一个单独的字符作为参数，并附加到 String 中
```
let mut s = String::from("lo");
s.push('l');
```

3. 使用 + 运算符
```
let s1 = String::from("Hello, ");
let s2 = String::from("world!");
let s3 = s1 + &s2; // 注意 s1 被移动了，不能继续使用
```
```+``` 运算符使用了 add 函数,标准库中的 add 使用泛型定义。其函数签名类似于：   
```
fn add(self, s: &str) -> String {
```
s2 使用了 &，意味着我们使用第二个字符串的 引用 与第一个字符串相加。这是因为 add 函数的 s 参数：只能将 &str 和 String 相加，不能将两个 String 值相加。不过等一下 —— 正如 add 的第二个参数所指定的，&s2 的类型是 &String 而不是 &str。



之所以能够在 add 调用中使用 &s2 是因为 &String 可以被 强转（coerced）成 &str。当add函数被调用时，Rust 使用了一个被称为 解引用强制多态（deref coercion）的技术，你可以将其理解为它把 &s2 变成了 ```&s2[..]```。因为 add 没有获取参数的所有权，所以 s2 在这个操作后仍然是有效的 String。  

签名中 add 获取了 self 的所有权，因为 self 没有 使用 &。这意味着s1 的所有权将被移动到 add 调用中，之后就不再有效。所以虽然 ```let s3 = s1 + &s2;``` 看起来就像它会复制两个字符串并创建一个新的字符串，而实际上这个语句会获取 s1 的所有权，附加上从 s2 中拷贝的内容，并返回结果的所有权。   

换句话说，它看起来好像生成了很多拷贝，不过实际上并没有：这个实现比拷贝要更高效。

如果想要级联多个字符串，+ 的行为就显得笨重了

对于更为复杂的字符串链接，可以使用 format! 宏：  
```
let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");

let s = format!("{}-{}-{}", s1, s2, s3);
```
format! 与 println! 的工作原理相同，不过不同于将输出打印到屏幕上，它返回一个带有结果内容的 String。这个版本就好理解的多，并且不会获取任何参数的所有权。

## 索引字符串
Rust 的字符串不支持索引  
因为：   
在内部，String 是一个 ```Vec<u8> ```的封装。  
```
let len = String::from("Hola").len();
```
在这里，len 的值是 4 ，这意味着储存字符串 “Hola” 的 Vec 的长度是四个字节：这里每一个字母的 UTF-8 编码都占用一个字节。

但是对于：  
```
let hello = "Здравствуйте";
let answer = &hello[0];

在这里每个 Unicode 标量值需要两个字节存储，使用 UTF-8 编码所需要24个字节
因此一个字符串字节值的索引并不总是对应一个有效的 Unicode 标量值
```
answer 的值应该是什么呢？它应该是第一个字符 З 吗？当使用 UTF-8 编码时，З 的第一个字节 208，第二个是 151，所以 answer 实际上应该是 208，不过 208 自身并不是一个有效的字母。返回 208 可不是一个请求字符串第一个字母的人所希望看到的，不过它是 Rust 在字节索引 0 位置所能提供的唯一数据。用户通常不会想要一个字节值被返回，即便这个字符串只有拉丁字母： 即便 ```&"hello"[0]``` 是返回字节值的有效代码，它也应当返回 104 而不是 h。为了避免返回意外的值并造成不能立刻发现的 bug，Rust 根本不会编译这些代码，并在开发过程中及早杜绝了误会的发生。


从 Rust 的角度来讲，事实上有三种相关方式可以理解字符串：字节、标量值和字形簇（最接近人们眼中 字母 的概念）   
比如这个用梵文书写的印度语单词 “नमस्ते”   
最终它储存在 vector 中的 u8 值看起来像这样：  
```
[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164, 224, 165, 135]
```
从字节角度理解：这里有 18 个字节，utf-8使用3字节表示一个字符，也就是计算机最终会储存的数据。  
从 Unicode 标量值的角度理解它们，也就像 Rust 的 char 类型那样，有六个 char,这些字节看起来像这样：   
```
['न', 'म', 'स', '्', 'त', 'े']
```
如果以字形簇的角度理解,就会得到人们所说的构成这个单词的四个字母：   
```
["न", "म", "स्", "ते"]
```
Rust 提供了多种不同的方式来解释计算机储存的原始字符串数据，这样程序就可以选择它需要的表现方式，而无所谓是何种人类语言。

最后一个 Rust 不允许使用索引获取 String 字符的原因是，索引操作预期总是需要常数时间 (O(1))。但是对于 String 不可能保证这样的性能，因为 Rust 必须从开头到索引位置遍历来确定有多少有效的字符

## 字符串 slice,索引字符串通常是一个坏点子
因为字符串索引应该返回的类型是不明确的：字节值、字符、字形簇或者字符串 slice。   
如果你真的希望使用索引创建字符串 slice 时，Rust 会要求你更明确一些。为了更明确索引并表明你需要一个字符串 slice，相比使用 [] 和单个值的索引，可以使用 [] 和一个 range 来创建含特定字节的字符串 slice：  
```
let hello = "Здравствуйте";

let s = &hello[0..4];
s 会是一个 &str，它包含字符串的头四个字节。早些时候，
我们提到了这些字母都是两个字节长的，所以这意味着 s 将会是 “Зд”。

如果获取 &hello[0..1] 会发生什么呢？答案是：Rust 在运行时会 
panic，就跟访问 vector 中的无效索引时一样
```

你应该小心谨慎的使用这个操作，因为这么做可能会使你的程序崩溃。

## 遍历字符串的方法
1. 如果你需要操作单独的 Unicode 标量值,最好的选择是使用 chars 方法。对 “नमस्ते” 调用 chars 方法会将其分开并返回六个 char 类型的值，接着就可以遍历其结果来访问每一个元素了：  
```
for c in "नमस्ते".chars() {
    println!("{}", c);
}
输出：
न
म
स
्
त
े
```

2. bytes 方法返回每一个原始字节
```
for b in "नमस्ते".bytes() {
    println!("{}", b);
}
输出：
224
164
// --snip--
165
135
```

3. 从字符串中获取字形簇是很复杂的，所以标准库并没有提供这个功能。crates.io 上有些提供这样功能的 crate。

不过请记住有效的 Unicode 标量值可能会由不止一个字节组成。


总而言之，字符串还是很复杂的。不同的语言选择了不同的向程序员展示其复杂性的方式。Rust 选择了以准确的方式处理 String 数据作为所有 Rust 程序的默认行为，这意味着程序员们必须更多的思考如何预先处理 UTF-8 数据。这种权衡取舍相比其他语言更多的暴露出了字符串的复杂性，不过也使你在开发生命周期后期免于处理涉及非 ASCII 字符的错误。


# slice
slice是一些储存在别处的 UTF-8 编码字符串数据的引用   
除了引用，另一个没有所有权的数据类型是 slice。  
slice 允许你引用集合中一段连续的元素序列，而不用引用整个集合。  
字符串 slice（string slice）是 String 中一部分值的引用  
```
let s = String::from("hello world");

let hello = &s[0..5];
let world = &s[6..11];
```

可以使用一个由中括号中的 ```[starting_index..ending_index] ```指定的 range 创建一个 slice，其中 starting_index 是 slice 的第一个位置，ending_index 则是 slice 最后一个位置的后一个值。在其内部，slice 的数据结构存储了 slice 的开始位置和长度，长度对应于 ending_index 减去 starting_index 的值。所以对于 let world = &s```[6..11]```; 的情况，world 将是一个包含指向 s 第 7 个字节（从 1 开始）的指针和长度值 5 的 slice。


对于 Rust 的 .. range 语法，如果想要从第一个索引（0）开始，可以不写两个点号之前的值
```
let s = String::from("hello");

let slice = &s[0..2];
let slice = &s[..2];

如果 slice 包含 String 的最后一个字节，也可以舍弃尾部的数字
let s = String::from("hello");
let len = s.len();
let slice = &s[3..len];
let slice = &s[3..];

可以同时舍弃这两个值来获取整个字符串的 slice
let slice = &s[..];
```


```
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s);

    s.clear(); // 错误!

    println!("the first word is: {}", word);
}
```
回忆一下借用规则，当拥有某值的不可变引用时，就不能再获取一个可变引用。因为 clear 需要清空 String，它尝试获取一个可变引用。Rust不允许这样做，因而编译失败。Rust 不仅使得我们的 API 简单易用，也在编译时就消除了一整类的错误！



## 字符串字面值就是 slice
```
let s = "Hello, world!";
这里 s 的类型是 &str：它是一个指向二进制程序特定位置
的 slice。这也就是为什么字符串字面值是不可变的；&str 是一个不可变引用。
```
字符串 slice 作为参数:  
在知道了能够获取字面值和 String 的 slice 后，我们对 first_word 做了改进，这是它的签名：  
```
fn first_word(s: &String) -> &str {
```
而更有经验的 Rustacean 会编写出示例 4-9 中的签名，因为它使得可以对 String 值和 &str 值使用相同的函数：  
```
fn first_word(s: &str) -> &str {
```
通过将 s 参数的类型改为字符串 slice 来改进 first_word 函数  
如果有一个字符串 slice，可以直接传递它。如果有一个 String，则可以传递整个 String 的 slice。定义一个获取字符串 slice 而不是 String 引用的函数使得我们的 API 更加通用并且不会丢失任何功能：  
```
fn main() {
    let my_string = String::from("hello world");

    // first_word 中传入 `String` 的 slice
    let word = first_word(&my_string[..]);

    let my_string_literal = "hello world";

    // first_word 中传入字符串字面值的 slice
    let word = first_word(&my_string_literal[..]);

    // 因为字符串字面值 **就是** 字符串 slice，
    // 这样写也可以，即不使用 slice 语法！
    let word = first_word(my_string_literal);//my_string_literal可不可以带&，有什么区别？

    
}
```
## 其他类型的 slice
字符串 slice，正如你想象的那样，是针对字符串的。不过也有更通用的 slice 类型。考虑一下这个数组：  
```

let a = [1, 2, 3, 4, 5];
```
就跟我们想要获取字符串的一部分那样，我们也会想要引用数组的一部分。我们可以这样做：  
```

let a = [1, 2, 3, 4, 5];

let slice = &a[1..3];
```
这个 slice 的类型是 ```&[i32]```。它跟字符串 slice 的工作方式一样，通过存储第一个集合元素的引用和一个集合总长度。你可以对其他所有集合使用这类 slice。第八章讲到 vector 时会详细讨论这些集合。

```
#![allow(unused)]
fn main() {
fn first_word(s: &String) -> usize {
    let bytes = s.as_bytes();//as_bytes 方法将 String 转化为字节数组：

    for (i, &item) in bytes.iter().enumerate()
    //iter 方法返回集合中的每一个元素，
    而 enumerate 包装了 iter 的结果，将这些元素作为元组的一部分来返回。
    enumerate 返回的元组中，第一个元素是索引，第二个元素是集合中元素的引用
    enumerate 方法返回一个元组，我们可以使用模式来解构，就像 Rust 中其他任何地方所做的一样。
     {
        if item == b' ' //引用就是对其值的引用，忘记c中的引用是指针，引用没有所有权，item还是代表值本身
        {
            return i;
        }
    }

    s.len()
}
}
```











b"..."	字节字符串字面值; 构造一个 ```[u8]``` 类型而非字符串   
b'...'	ASCII 码字节字面值   
'...'	字符字面值   
```
fn main() {
//依次输出字节字符串字面值    
let a =b"0xF0";
for i in a {
    println!("{}", i );
}

//输出ASCII 码字节字面值
let b=b'a'
 println!("{}", b);
}

let c =b' ';

    println!("{}", c );
 ```


 所有权、借用和 slice 这些概念让 Rust 程序在编译时确保内存安全。Rust 语言提供了跟其他系统编程语言相同的方式来控制你使用的内存，但拥有数据所有者在离开作用域后自动清除其数据的功能意味着你无须额外编写和调试相关的控制代码。
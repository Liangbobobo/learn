# vector
vector 允许我们在一个单独的数据结构中储存多于一个的值，它在内存中彼此相邻地排列所有的值。vector 只能储存相同类型的值。

## 新建 vector
1. new
```
let v: Vec<i32> = Vec::new();
```
2. vec! 宏    
一旦插入值 Rust 就可以推断出想要存放的类型,使用初始值来创建一个 Vec
```
let v = vec![1, 2, 3];
```

## 更新 vector
可以使用 push 方法向一个 vector 增加元素   
```

let mut v = Vec::new(); //Rust 也根据数据做出如此判断，所以不需要 Vec<i32> 注解。

v.push(5);
v.push(6);
v.push(7);
v.push(8);
```

类似于任何其他的 struct，vector 在其离开作用域时会被释放,丢弃 vector 时也会丢弃其所有元素

## 读取 vector 的元素
有两种方法引用 vector 中储存的值  
Rust 有两个引用元素的方法的原因是程序可以选择如何处理当索引值在 vector 中没有对应值的情况   
```
let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &v[100];
let does_not_exist = v.get(100);
```

对于第一个 [] 方法，当引用一个不存在的元素时 Rust 会造成 panic。这个方法更适合当程序认为尝试访问超过 vector 结尾的元素是一个严重错误的情况，这时应该使程序崩溃。  
当 get 方法被传递了一个数组外的索引时，它不会 panic 而是返回 None。当偶尔出现超过 vector 范围的访问属于正常情况的时候可以考虑使用它。接着你的代码可以有处理 Some(&element) 或 None 的逻辑，如第六章讨论的那样。例如，索引可能来源于用户输入的数字。如果它们不慎输入了一个过大的数字那么程序就会得到 None 值，你可以告诉用户当前 vector 元素的数量并再请求它们输入一个有效的值。这就比因为输入错误而使程序崩溃要友好的多！   

一旦程序获取了一个有效的引用，借用检查器将会执行所有权和借用规则（第四章讲到）来确保 vector 内容的这个引用和任何其他引用保持有效。